###一、数据结构

####1. 基本概念

&emsp;数据(data):是描述客观事物的数值、字符以及能输入机器且能被处理的各种符号集合。  
&emsp;数据元素(data element):数据的基本单位，是数据集合的个体，数据元素通常由若干数据项组成。数据项具有原子性是不可分割的最小单位。
&emsp;数据对象(data object):是性质相同的数据元素的集合，是数据的子集。  
&emsp;数据结构(data structure): 是指相互之间存在一种或多种特定关系的数据元素的集合。是组织并存储数据以便能够有效使用的一种专门格式，它用来反映一个数据的内部构成，即一个数据由哪些成分数据构成，以什么方式构成，呈什么结构。  

&emsp;数据的逻辑结构按照数据元素之间相互关系的特性来分，可以分为以下四种结构：集合、线性结构、树形结构和圆状结构。  
&emsp;数据的逻辑结构可以采用两种方法来描述：二元祖、图形。  
&emsp;数据结构的二元祖表示形式为：  
       数据结构={D,S}  
       其中D是数据元素的集合；S是D中数据元素之间的关系集合，并且数据元素之间的关系是使用序偶来表示的，序偶是由两个元素x和y按一定顺序排列而成的二元祖，记作<x,y>  x是第一元素，y是第二元素
       当使用图形来表示数据结构时，是用图形中的点来表示数据元素，用图形中的弧来表示数据元素之间的关系。如果数据元素x与y之间有关系<x,y>，则在图形中有从表示x的点出发到达表示y的点的一条弧。  
         
例1 一种数据结构二元祖表示为set={K,R},其中  
       K = {01,02,03,04,05}  
       R =  {}  
       可以看到在数据结构set中，只有数据元素的集合非空，而数据元素之间除了同属一个集合之外不存在任何关系，表明该数据结构只考虑数据元素而不考虑他们之间的关系，我们把具有这种特点的数据结构称为集合结构。  
例2 一种数据结构二元祖表示为linearity = {K,R},其中  
       K = {01,02,03,04,05}  
       R = {<02,04>,<03,05>,<05,02>,<01,03>}  
       可以看到在数据结构linearity中，数据元素之间是有序的，在这些数据元素中又一个可以被称为"第一个"元素01的数据元素；还有一个可以被称为最后一个元素04的数据元素；除第一个元素以外每个数据元素有且仅有一个直接前驱元素，除最后一个元素以外每个数据元素有且仅有一个直接后续元素，这种数据结构的特点是数据元素之间是1对1的联系，即线性关系，这种结构称为线性结构。  
       
例3 一种数据结构二元祖表示为tree = (K，R),其中  
       K = {01,02,03,04,05,06}  
       R = {<01,02>,<01,03>,<02,04>,<02,05>,<03,06>}  
       可以看到在数据结构tree中，除了一个数据元素（元素01）以外每个数据元素有且仅有一个直接前驱元素，但是可以有多个直接后续元素。这种数据结构的特点是元素之间是1对N的联系，此种特点的数据结构称为树结构。  
例4 一种数据结构二元祖表示为graph = (K,R),其中  
       K = {01,02,03,04,05}  
       R = {<01,02>,<01,05>,<02,01>,<02,03>,<02,04>,<03,02>,<04,02>,<04,05>,<05,01>,<05,04>}  
       可以看到在数据结构graph中，每个数据元素可以有多个直接前驱元素，也可以多个直接后续元素，这种数据结构特点是数据元素之间是M对N的联系，此种特点的数据结构称为图结构。  
         
&emsp;数据元素之间的关系在计算机中主要有两种不同的表示方法：顺序映像和非顺序映像。  
&emsp;并由此得到两种不同的存储结构：顺序存储结构和链式存储结构；顺序存储结构的特点是：数据元素的存储对应与一块连续的存储空间，数据元素之间的前驱和后续关系通过数据元素在存储器中的相对位置来反映。链式存储结构的特点是数据元素的存储对应的是不连续的存储空间，每个存储节点对应一个需要存储的数据元素，元素之间的逻辑关系通过存储节点之间的链接关系反映出来。    


###### 2. 抽象数据类型
&emsp;数据类型是一组性质相同的数据元素的集合以及加在这个集合上的一组操作。
&emsp;抽象数据类型(ADT)由一种数据模型和在该数据模型上的一组操作组成。
&emsp;抽象数据类型包括定义和实现两个方面，其中定义是独立于实现的。抽象数据类型的定义仅取决于它的逻辑特性，而与其在计算机内部的实现无关。  
&emsp;根据抽象类型的概念，对抽象数据类型进行定义就是约定抽象数据类型的名字，同时约定在该类型上定义的一组运算的各个运算的名字，明确各个运算分别要多少参数，这些参数的含义和顺序以及运算的功能。  
为此抽象数据类型可以使用一个三元组来表示：  
    ADT = (D,S,P)  
    其中D是数据对象，S是D上的关系集，P是加在D上的一组操作。  
    在定义抽象数据类型时，我们使用以下格式：  
    ADT 抽象数据类型名{  
        数据对象: <数据对象的定义>  
        数据关系: <数据关系的定义>  
        基本操作: <基本操作的定义>  
        }

###二、算法及性能分析

####1. 算法

&emsp;算法(algorithm)是指令的集合，是为解决特定问题而规定的一系列操作。它是明确定义的可计算过程，以一个数据集合作为输入并产生一个数据集合作为输出，一个算法通常来说具有以下五个特性:  
* 输入: 一个算法应以待解决的问题的信息作为输入。  
* 输出: 输入对应指令集处理后得到的信息。  
* 可行性: 算法是可行的，即算法中的每一条指令都是可以实现的，均能在有限的时间内完成。  
* 有穷性: 算法执行的指令个数是有限的，每个指令又是在有限事件内完成的，因此整个算法也是在有限时间内可以结束。  
* 确定性：算法对于特定的合法输入，其对应的输出是唯一的。即当算法从一个特定的输入开始，多次执行同一个指令集结果总是相同的。  
####2.算法分析

  &emsp;在计算机资源中，最重要的就是时间与空间，评价一个算法性能的好坏，实际上就是评价算法的资源占用问题。

##### 2.1 数学基础

&emsp;一般来说，估计算法资源消耗所需的分析是一个理论问题，先从某些数学定义开始。

&emsp;**定义1** 如果存在正常数c和n<sub>0</sub>使得当$N$$\geq$$n$<sub>0</sub>时$T(N)$$\leq$$cf(N)$ ,则记为$T(N)$=$O(f(N)$\)。

&emsp;**定义2** 如果存在正常数c和n<sub>0</sub> 使得当$N\geq n$<sub>0</sub>时$T(N)\geq $$c$g($N$),则记为$T(N)$=$\Omega$(g($N$))。

&emsp;**定义3** $T(N)$= $\Theta$\($h(N)$\)当且仅当$T(N)$=O\($h(N)$\)和$T(N)$=$\Omega$\($h(N)$\)。

&emsp;**定义4** 如果对每一正常数$c$都存在常数$n$<sub>0</sub>使得当$N$>$n$<sub>0</sub>时$T(N)$<$cp(N)$,则$T(N) $= $o(p(N))$。或者如果$T(N) =O(p(N))$且$T(N) \neq \Theta (p(N))$,则$T(N)=o(p(N))$。

&emsp;当$T(N)=O(f(N))$时,是在保证函数$T(N)$是在以不快于$f(N)$的速度增长;因此$f(N)$是$T(N)$的一个**上界**。这意味着$f(N)= \Omega(T(N))$,于是我们说$T(N)$是$f(N)$的一个**下界**。

&emsp;重要结论:

&emsp;**法则 1 ：**

&emsp;如果$T_1(N)=O((f(N)))$且$T_2(N)=O($g$(N))$,那么

&emsp;(a) $T_1(N)+T_2(N)=O(f(N)+$g$(N))$(直观和非正式可以写成max$(O(f(N)),O($g$(N)))$)。

&emsp;(b) $T_1(N)*T_2(N)=O(f(N)*$g$(N))$。

&emsp;**法则 2 ：**

&emsp;如果$T(N)$是一个$k$次多项式,则$T(N)= \Omega (N^k)$。

&emsp;**法则 3 ：**

&emsp;对任意常数$k$,log<sup>k</sup>$N$=$O(N)$。它告诉我们对数增长的非常缓慢。



&emsp;*典型增长率*

| 函数               | 名称     |
| ------------------ | -------- |
| $c$                | 常数     |
| log$N$             | 对数     |
| log<sup>2</sup>$N$ | 对数平方 |
| $N$                | 线性的   |
| $N$log$N$          |          |
| $N^2$              | 二次的   |
| $N^3$              | 三次的   |
| $2^N$              | 指数的   |



&emsp;需要注意的是，将常数或低阶项放进大$O$是非常坏的习惯。不要写成$T(N)=O(2N^2)$或$T(N)=O(N^2+N)$。在这两种情形下,正确的形式是$T(N)=O(N^2)$。这就是说在大$O$表示法任何分析中，各种简化都是可能发生的。低阶项一般被忽略，而常数也可以弃掉。此时要求的精度是很粗糙的。

&emsp;我们总能够通过计算极限$$ \lim_{N \to \infty} \frac{f(N)}{g(N)} $$来确定两个函数的$f(N)$和g$(N)$的相对增长率，必要时可以使用*洛必达法则*。该极限可以有四种可能的值：

- 极限是0：意味着$f(N)=o($g$(N))$。
- 极限是$c \neq 0$:意味着 $f(N)= \Omega($g$(N))$。
- 极限是$\infty$:意味着g$(N)$=$o(f(N))$。

##### 2.2 要分析的问题

&emsp;通常，要分析的最重要的资源就是运行时间。剩下的主要因素则是所使用的算法以及对该算法的输入。

&emsp;典型的情形是，输入的大小是主要的考虑方面。定义两个函数$T$<sub>avg</sub>$(N)$和$T$<sub>worst</sub>$(N)$,分别为算法对于输入量$N$所花费的平均运行时间和最坏情况的运行时间。

&emsp;偶尔也分析一个算法最好情形的性能。不过，通常这没有什么重要意义，因为它不代表典型的行为。平均情形性能常常反映典型的行为，而最坏情形的性能则代表对任何可能输入的性能的一种保证。

##### 2.3 运行时间计算

&emsp;为了简化分析，将采纳如下约定：不存在特定的时间单位。因此，我们抛弃一些前导的常数。我们还将抛弃低阶项，从而要做的就是计算大$O$运行时间。

###### 2.3.1 一个简单的例子



```java
public static int sum( int n){
  int partialSum;
1  partialSum = 0;
2  for( int i = 1;i <= n; i++ ){
3    partialSum += i * i * i;
  }
4  return partialSum;
}
```

&emsp;首先, 所有的声明均不计时间。第1行和第4行各占一个时间单元。第3行每执行一次占用4个时间单元(两次乘法，一次加法和一次赋值)，而执行$N$次共占用4N个时间单元。第2行在初始化$i$、测试$i \leq N$和对$i$的自增运算隐含着开销。所有这些的总开销是初始化1个单元时间，所有的测试为$N+1$个单元时间，而所有的自增运算为$N$个单元时间，共2$N$+2个时间单元(包含自增和赋值两步)。忽略调用方法和返回值得开销，得到总量是6$N$+4个时间单元。因此，我们说该方法是$O(N)$。

&emsp;如果每次分析一个程序都要演示所有这些工作，那么这项任务很快就会变成不可行的负担。采用大$O$的结果,可以省略很多步骤。例如，第3行(每次执行时)显然是$O(1)$的结果，因此精确计算它究竟是2、3还是4个时间单位是愚蠢的；这无关紧要。第1行与for循环相比显然不重要，所以在这里花费时间也是不明智的。

###### 2.3.2 一般法则

&emsp;**法则 1 for循环**

&emsp;一个for循环的运行时间至多是该for循环内部那些语句(包含测试)的运行时间乘以迭代的次数。

&emsp;**法则 2 嵌套for循环**

&emsp;从里向外分析这些循环。在一组嵌套循环内部的一条语句总的运行时间为该语句的运行时间乘以该组所有的for循环的大小的乘积。

&emsp;例如$ O(N^2)$

```java
for(int i = 0;i < n;i++){
  for(int j =0 ;j<n;j++){
    k++;
   }
}
```

 &emsp;**法则 3 顺序语句**

&emsp;将各个语句的运行时间求和即可

&emsp;例如 $O(N)+O(N^2)=O(N^2)$:

```java
for(i=0;i<n;i++)
  a[i] = 0;
for(int i = 0;i < n; i++)
  for(int j = 0; j < n; j++)
    a[i] += a[j] + i + j;
```



&emsp;**法则 4 if/else语句**

&emsp;对于程序片段

```java
if(condition)
  s1
  else
    s2

```

&emsp;一个if/else语句的运行时间从不超过判断的运行时间再加上$s1$和$s2$中运行时间长者的总的运行时间。

&emsp;在某些情形下这么估计有些过头，但绝不会估计过低。

###### 2.3.3 最大子序列和问题的求解



&emsp;算法 1  $O(N^3)$

```java
public static int maxSubSum1( int[] a){
1  int maxSum = 0;
2  for(int i = 0; i< a.length; i++){
3    for(int j = i; j< a.length; j++ ){
4     int thisSum = 0;
5    for(int k = i;k<=j;k++)
6        thisSum += a[k];
7      if(thisSum > maxSum)
8        maxSum = thisSum;
    }
  }
9 return maxSum;
}
```

&emsp;该算法运行时间为$O(N^3)$,完全取决于第5行和第6行，它们由一个含于三重嵌套for循环中$O(1)$语句组成。第8行上的循环大小为$N$。

&emsp;第2个循环大小为$N-i$,第三个循环大小为$j-i+1$，假设最坏情况大小为$N$。因此总数为$O(1*N*N*N)=O(N^3)$。而第1行总开销是$O(1)$，而语句第7和8行也只不过是$O(N^2)$，只是两层循环内部的简单表达式。

&emsp;算法 2  $O(N^2)$

```java
public static int maxSubSum2(int[] a){
  int maxSum = 0;
  for(int i = 0; i < a.length;i++){
    int thisSum = 0;
    for(int j =i;j < a.length; j++){
      thisSum += a[j];
      if(thisSum > maxSum)
        maxSum = thisSum;
    }
  }
  return maxSum; 
}
```



&emsp;算法 3 $N$log$N$  递归分治策略

```java
private static int maxSumRec(int[] a, int left, int right){
  if(left == right){
    if(a[left] > 0)
      return a[left];
    else
      return 0;
  }
  int center = (left+right)/2;
  int maxLeftSum = maxSumRec(a,left,center);
  int maxRightSum = maxSumRec(a,center+1,right);
  
  int maxLeftBorderSum = 0;
  int leftBorderSum = 0;
  for(int i = center;i >= left;i--){
    leftBorderSum +=a[i];
    if(leftBorderSum > maxLeftBorderSum)
      maxLeftBorderSum = leftBorderSum;
  }
  int maxRightBorderSum = 0;
  int rightBorderSum = 0;
  for(int i = center + 1;i <= right; i++){
    rightBorderSum += a[i];
    if(rightBorderSum > maxRightBorderSum)
      maxRigthBorderSum = rightBorderSum;
  }
  return max3(maxLeftSum,maxRightSum,maxLeftBorderSum+maxRightBorderSum);
}

public static int maxSubSum3(int[] a){
  return maxSumRec(a,0,a.length-1);
}
```



&emsp;算法 4  $O(N)$

```java
public static int maxSubSum4(int[] a){
  int maxSum = 0;
  int thisSum = 0;
  for(int j = 0 ;j < a.length; j++){
    thisSum += a[j];
    if(thisSum > maxSum)
      maxSum = thisSum;
    else if(thisSum <0)
      thisSum = 0;
  }
  return maxSum;
}
```



&emsp;任意时刻，算法都能对它已经读入的数据给出子序列问题的正确答案(其他算法那不具备这个特性)，具有这种特性的算法叫作**联机算法**。仅需常量空间并以线性时间运行。

###### 2.3.4 运行时间中的对数

&emsp;分析算法最混乱的方面大概集中在对数上面。某些分治算法将以$O(NlogN)$时间运行。此外，对数最常出现的规律可概括为下列一般法则： 如果一个算法用常数时间($O(1)$)将问题的大小削减为其中一部分(通常是1/2)，那么该算法就是$O(logN)$。另一方面如果使用常数时间只是把问题减少一个常数的数量(如将问题减少1)，那么这种算法就是$O(N)$的。

&emsp;具有对数特点的三个例子：

&emsp;**折半查找**

&emsp;*折半查找*： 给定一个整数$X$ 和整数$A_0,A_1,...,A_{n-1}$，后者已经预先排序并在内存中，求下标$i$使得$A_i=X$,如果$X$不在数据中，则返回$i = -1$。

&emsp;明显的解法是从左到右扫描数据，其运行花费线性时间。然而，这个算法没有用到该表已经排序的事实，这就使得算法很可能不是最好的。一个好的策略是验证$X$是否是居中的元素。如果是，则答案找到。如果$X$小于居中元素，那么应用同样的策略于居中元素左边已排序的子序列；同理，如果$X$大于居中元素，那么我们检查数据的右半部分。

```java
public static <AnyType extends Comparable<? super AnyType>> int binarySearch(AnyType[] a, AnyType x){
  int low = 0;
  int high = a.length - 1;
  while(low <= high){
    int mid = (low+high)/2;
    if(a[mid].compareTo(x)<0)
      low = mid + 1;
    else if(a[mid].compareTo(x)>0)
      high = mid - 1;
    else
      return mid;
  }
  return NOT_FOUND;//Not_FOUND is defined as -1
}
```



&emsp;**欧几里得算法**

&emsp;*最大公约数*

```java
public static long gcd(long m , long n){
  while( n != 0){
    long rem = m % n;
    m = n;
    n = rem;
  }
  return m;
}
```



&emsp;定理 1 如果$M > N$，则$M$ mod $N$ < $M/2$。

&emsp;**幂运算**

```java
public static long pow(long x,int n){
  if(n == 0)
    return 1;
  if(n == 1)
    return x;
  if(isEven(n))
    return pow(x*x,n/2);
  else
    return pow(x*x,n/2)*x;
}
```

